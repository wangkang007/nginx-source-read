#一篇文章让你分清楚BIO、NIO、AIO
## IO分类
目前常用的IO主要分类为BIO、NIO、AIO，每一种IO其实都是为了解决问题存在的，大部分网上都会说NIO比BIO效率高，其实我觉得主要还是分场景的。
## BIO(Blocking IO)
BIO是一种比较简单的模型，比较容易理解，举个简单的例子来说，比如web场景下访问数据库然后等待返回结果，查询数据A->查询数据B，这两次查询我们都需要等待返回才能继续进行下去。这样一来就需阻塞住一个线程等待MYSQL返回结果，当访问量比较大的情况下，就需要成千上万个线程来运行，就线程而言，创建太多会因为降低线程的效率，光线程切换都耗费不少时间。
![](https://github.com/wangkang007/nginx-source-read/blob/master/nginx%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/img/BIOModel.png?raw=true)

针对于上面的情况，会有两个问题，即使有上千个线程，cpu依然不会太高，因为大部分都是在等待MYSQL进行查询计算返回结果，对于web服务来说大部分线程都是在休眠状况，为了解决这种问题，NIO就发挥出作用了
## NIO(Non-Blocking IO)
对于查询这种操作，主要的计算是依赖于DB的，对于web端而言只是简单的发指令而已然后接受数据，就需要创建了上千个个线程来一起等待，既然大部分线程都在处理等待这个操作，莫不如由一个或者几个来一起管理呢？NIO就是针对于这种情况出现的，先来大概了解下模型：

![](https://github.com/wangkang007/nginx-source-read/blob/master/nginx%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/img/NIO1.png?raw=true)

可以看到NIO主要核心是采用单个线程来对应业务的处理，因为总得来说做业务处理多线程不会比单线程更快，因为多线程需要涉及到线程切换和上下文的保存。

对于一个复杂的系统来说不仅仅只有处理业务，还需要去调用其他系统。针对上面的select再次增加一些复杂的场景(待补充)

综上所述，既然NIO这么好，为什么不用这种编程模式来写业务？(补充一个复杂的事件机制的图)

采用NIO来写业务的话就会导致业务拆分得比较分散，代码比较难懂，编程难度相当高

